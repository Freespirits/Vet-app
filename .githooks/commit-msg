#!/bin/sh

# Hook de mensagem de commit para projeto React Native VetApp
# Valida e padroniza mensagens de commit

commit_regex='^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .{1,50}'

# Ler a mensagem de commit
commit_msg_file="$1"
commit_msg=$(cat "$commit_msg_file")
first_line=$(echo "$commit_msg" | head -n1)

echo "ðŸ” Validando mensagem de commit..."

# Verificar se nÃ£o estÃ¡ vazia
if [ -z "$commit_msg" ]; then
    echo "âŒ Mensagem de commit nÃ£o pode estar vazia"
    exit 1
fi

# Verificar se a primeira linha nÃ£o estÃ¡ muito longa
if [ ${#first_line} -gt 72 ]; then
    echo "âŒ Primeira linha muito longa (${#first_line} caracteres). MÃ¡ximo: 72"
    echo "Linha atual: $first_line"
    exit 1
fi

# Verificar se a primeira linha nÃ£o estÃ¡ muito curta
if [ ${#first_line} -lt 10 ]; then
    echo "âŒ Primeira linha muito curta (${#first_line} caracteres). MÃ­nimo: 10"
    echo "Linha atual: $first_line"
    exit 1
fi

# Verificar formato padrÃ£o (Conventional Commits)
if ! echo "$first_line" | grep -Eq "$commit_regex"; then
    echo "âŒ Formato de commit invÃ¡lido!"
    echo ""
    echo "ðŸ“‹ Use o formato: tipo(escopo): descriÃ§Ã£o"
    echo ""
    echo "Tipos vÃ¡lidos:"
    echo "  feat:     Nova funcionalidade"
    echo "  fix:      CorreÃ§Ã£o de bug"
    echo "  docs:     DocumentaÃ§Ã£o"
    echo "  style:    FormataÃ§Ã£o, ponto e vÃ­rgula, etc"
    echo "  refactor: RefatoraÃ§Ã£o de cÃ³digo"
    echo "  test:     AdiÃ§Ã£o ou correÃ§Ã£o de testes"
    echo "  chore:    ManutenÃ§Ã£o, dependÃªncias, etc"
    echo "  perf:     Melhoria de performance"
    echo "  ci:       ConfiguraÃ§Ã£o de CI/CD"
    echo "  build:    Sistema de build"
    echo "  revert:   Reverter commit anterior"
    echo ""
    echo "Exemplos vÃ¡lidos:"
    echo "  feat(auth): adicionar login com Google"
    echo "  fix(agenda): corrigir bug no agendamento"
    echo "  docs: atualizar README com instruÃ§Ãµes"
    echo "  refactor(pets): reorganizar componentes"
    echo ""
    echo "Sua mensagem: $first_line"
    exit 1
fi

# Verificar se comeÃ§a com letra maiÃºscula apÃ³s o tipo
description=$(echo "$first_line" | sed 's/^[^:]*: *//')
first_char=$(echo "$description" | cut -c1)

if ! echo "$first_char" | grep -q '[a-z]'; then
    echo "âš ï¸  RecomendaÃ§Ã£o: descriÃ§Ã£o deve comeÃ§ar com letra minÃºscula"
    echo "Exemplo: 'feat: adicionar nova funcionalidade' (nÃ£o 'Adicionar')"
fi

# Verificar se termina com ponto
if echo "$first_line" | grep -q '\.$'; then
    echo "âš ï¸  RecomendaÃ§Ã£o: nÃ£o termine a primeira linha com ponto"
fi

# Verificar palavras nÃ£o recomendadas
forbidden_words="bug|fix|corrigir|arrumei|melhorei|fiz"
if echo "$first_line" | grep -iq "\b($forbidden_words)\b"; then
    echo "âš ï¸  Evite palavras genÃ©ricas. Seja mais especÃ­fico sobre o que foi alterado."
fi

# Verificar se hÃ¡ segunda linha vazia (boa prÃ¡tica)
second_line=$(echo "$commit_msg" | sed -n '2p')
if [ ! -z "$second_line" ]; then
    echo "âš ï¸  RecomendaÃ§Ã£o: deixe a segunda linha vazia para separar tÃ­tulo do corpo"
fi

# Verificar se hÃ¡ corpo da mensagem e se estÃ¡ bem formatado
line_count=$(echo "$commit_msg" | wc -l)
if [ "$line_count" -gt 2 ]; then
    echo "âœ… Mensagem tem corpo detalhado - muito bom!"
    
    # Verificar se as linhas do corpo nÃ£o sÃ£o muito longas
    echo "$commit_msg" | tail -n +3 | while IFS= read -r line; do
        if [ ${#line} -gt 72 ]; then
            echo "âš ï¸  Linha do corpo muito longa (${#line} caracteres): $line"
        fi
    done
fi

# Extrair tipo e escopo para categorizaÃ§Ã£o
commit_type=$(echo "$first_line" | sed 's/\([^(]*\).*/\1/')
commit_scope=$(echo "$first_line" | sed -n 's/[^(]*(\([^)]*\)).*/\1/p')

echo "ðŸ“Š EstatÃ­sticas do commit:"
echo "  Tipo: $commit_type"
if [ ! -z "$commit_scope" ]; then
    echo "  Escopo: $commit_scope"
fi
echo "  Tamanho da mensagem: ${#commit_msg} caracteres"
echo "  Linhas: $line_count"

# Adicionar estatÃ­sticas ao arquivo de log
{
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $commit_type"
    if [ ! -z "$commit_scope" ]; then
        echo "  Escopo: $commit_scope"
    fi
    echo "  Mensagem: $first_line"
    echo "---"
} >> .git/commit_stats.log

# Verificar padrÃµes especÃ­ficos do projeto VetApp
case "$commit_scope" in
    "auth"|"login"|"perfil")
        echo "ðŸ” Commit relacionado Ã  autenticaÃ§Ã£o"
        ;;
    "pets"|"animais"|"pacientes")
        echo "ðŸ¾ Commit relacionado aos pets/pacientes"
        ;;
    "agenda"|"consultas"|"agendamento")
        echo "ðŸ“… Commit relacionado Ã  agenda/consultas"
        ;;
    "biblioteca"|"medicamentos"|"library")
        echo "ðŸ“š Commit relacionado Ã  biblioteca veterinÃ¡ria"
        ;;
    "backup"|"dados")
        echo "ðŸ’¾ Commit relacionado a backup/dados"
        ;;
    "ui"|"interface"|"design")
        echo "ðŸŽ¨ Commit relacionado Ã  interface"
        ;;
    "database"|"supabase"|"db")
        echo "ðŸ—„ï¸  Commit relacionado ao banco de dados"
        ;;
esac

# VerificaÃ§Ãµes especÃ­ficas por tipo
case "$commit_type" in
    "feat")
        echo "ðŸŽ‰ Nova funcionalidade adicionada!"
        ;;
    "fix")
        echo "ðŸ› Bug corrigido!"
        ;;
    "perf")
        echo "âš¡ Melhoria de performance!"
        ;;
    "refactor")
        echo "â™»ï¸  CÃ³digo refatorado!"
        ;;
    "test")
        echo "ðŸ§ª Testes adicionados/modificados!"
        ;;
    "docs")
        echo "ðŸ“ DocumentaÃ§Ã£o atualizada!"
        ;;
esac

# SugestÃµes baseadas no tipo de commit
if [ "$commit_type" = "feat" ]; then
    echo ""
    echo "ðŸ’¡ Lembrete para nova funcionalidade:"
    echo "  - Testes foram adicionados?"
    echo "  - DocumentaÃ§Ã£o foi atualizada?"
    echo "  - Interface estÃ¡ responsiva?"
fi

if [ "$commit_type" = "fix" ]; then
    echo ""
    echo "ðŸ’¡ Lembrete para correÃ§Ã£o:"
    echo "  - O bug foi testado em diferentes cenÃ¡rios?"
    echo "  - NÃ£o causou regressÃµes?"
fi

echo "âœ… Mensagem de commit validada com sucesso!"

# Opcional: Salvar estatÃ­stica de tipos de commit
commit_stats_file=".git/commit_type_stats.txt"
if [ -f "$commit_stats_file" ]; then
    current_count=$(grep "^$commit_type:" "$commit_stats_file" | cut -d: -f2 || echo "0")
    new_count=$((current_count + 1))
    
    # Atualizar ou adicionar linha
    if grep -q "^$commit_type:" "$commit_stats_file"; then
        sed -i "s/^$commit_type:.*/$commit_type:$new_count/" "$commit_stats_file"
    else
        echo "$commit_type:$new_count" >> "$commit_stats_file"
    fi
else
    echo "$commit_type:1" > "$commit_stats_file"
fi

exit 0
